#!/usr/bin/python
# import multiprocessing
import json
import logging
import re
import subprocess
import sys
import time
from os import getcwd

__path__ = format(getcwd())
logging.basicConfig(filename=__path__+'/scribe_pipe11.log',level=logging.DEBUG)

from threading import Thread
from Queue import Queue

from shlex import split

from nginx_log_parser import NginxLogParser

from datetime import datetime, timedelta
from pytz.tzinfo import StaticTzInfo

class OffsetTime(StaticTzInfo):
    def __init__(self, offset):
        """A dumb timezone based on offset such as +0530, -0600, etc.
        """
        hours = int(offset[:3])
        minutes = int(offset[0] + offset[3:])
        self._utcoffset = timedelta(hours=hours, minutes=minutes)

def load_datetime(value, format):
    if format.endswith('%z'):
        format = format[:-2]
        offset = value[-5:]
        value = value[:-5]
        return OffsetTime(offset).localize(datetime.strptime(value, format))

    return datetime.strptime(value, format)

def dump_datetime(value, format):
    return value.strftime(format)

commandline = __path__ + '/piwik_pipe.sh'
parser = NginxLogParser('$request_time $remote_addr $sent_http_x_cache [$time_local] ' + \
			'"$request" $http_host $status $body_bytes_sent ' + \
			'"$http_referer" "$http_user_agent" "$http_range"')
a_k1 = re.compile('(\/[a-zA-Z0-9]{32}\/[a-zA-Z0-9]{8}\/)+')
a_k2 = re.compile('(\/[a-zA-Z0-9]{32}\/)+')
a_k3 = re.compile('(\/[a-zA-Z0-9]{42}\/)+')

a_ts = re.compile('(.*)\/[0-9]+\.(ts)')
a_ts1 = re.compile('(.*)\_[0-9]+\.(ts)')
a_ts2= re.compile('(.*)(?:[_-])[0-9]+\.(ts|m3u8)')

h_k1 = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(\:\d+)?$")
h_k2 = re.compile("\:\d+")


#cdn_gg0 = re.compile("^.*(htv|thvl).*$")
#cdn_gg1 = re.compile("^.*(vtv).*$")


NPIPE = 1

def process_message(pp):
    if not pp or pp is None:
        return None

    cur = load_datetime(pp['time_local'], '%d/%b/%Y:%H:%M:%S %z')
    localtime = cur.isoformat()

    timezonerr = pp['time_local'].split(" ")
    if len(timezonerr) < 1 :
        return None
    timezone = timezonerr[1]
    request_urirr =  pp["request"].split(" ")
    if len(request_urirr) < 1 :
        return None
    #This should be request_urirr[1] not request_urir
    request_uri = request_urirr[1]
    request_uri = request_uri.split('?')[0]

    request_uri = re.sub(a_k1,'/$tk$/$ts$/', request_uri, re.M)
    request_uri = re.sub(a_k2,'/$tk$//', request_uri, re.M)
    request_uri = re.sub(a_k3,'/$tk$//', request_uri, re.M)
    request_uri = re.sub(a_ts,r'\1/$idx$.\2', request_uri , re.M)
    request_uri = re.sub(a_ts1,r'\1_$idx$.\2', request_uri , re.M)
    request_uri = re.sub(a_ts2,r'\1_$idx$.\2', request_uri , re.M)


    referer = pp["http_referer"]
    referer = referer.split('?')[0]

    http_host = pp["http_host"]
    if http_host == '-':
        return None
    match_ip = re.match(h_k1,http_host)
    if match_ip:
        return  None
    match_port = re.match(h_k2,http_host)
    if match_port:
        return None

    body_bytes_sent = pp["body_bytes_sent"]
    if pp["status"] == "206":
        pp["status"] = "200"
    return json.dumps({
        "ip": pp["remote_addr"],
        "host": http_host,
        "path": request_uri,
        "status": pp["status"],
        "referrer": referer,
        "user_agent": pp["http_user_agent"],
        "length": body_bytes_sent,
        "generation_time_milli": pp["request_time"],
        "timezone":timezone,
        "date": localtime})


import psutil

q_msg = Queue()
ISB=1

def kill(proc_pid):
    process = psutil.Process(proc_pid)
    for proc in process.children(recursive=True):
        proc.kill()
    process.kill()

def reload(s):
    s.stdin.flush()
    time.sleep(5)
    kill(s.pid)
    time.sleep(5)

def process_queue(i, q):
    now = datetime.now()
    logging.info("[%s] t:%d" % (now, i))
    command = split("%s %d" % (commandline, i))
    s = subprocess.Popen(command, bufsize=ISB, stdin=subprocess.PIPE)

    #wait for the above pipe opened
    time.sleep(1)

    logging.info("[%s] fork pid:%s" % (now, s.pid))
    while True:
        try:
            if q.empty():
                continue
            msg = q.get()
            if msg is None:
                continue
            #msgp = None
            msgp = parser.parse_line(msg)
            if msgp is None:
                continue
            #mm = None
            mm = process_message(msgp)
            if mm is not None:
                #logging.info(str(mm))
                #everything is all good until here
                s.stdin.write("%s\n" % str(mm))
        #except IOError as e:
        #    if e.errno == errno.EPIPE:
        #        reload(s)
        #        s = subprocess.Popen(command, bufsize=ISB, stdin=subprocess.PIPE)
        #    pass
        except IOError as err:
            logging.info("[%s] e1:%s" % (datetime.now(), err))
            reload(s)
            s = subprocess.Popen(command, bufsize=ISB, stdin=subprocess.PIPE)
        except Exception, e:
            #TODO: why list index goes out of range???
            logging.info("[%s] e1 Exception:%s" % (datetime.now(), e))

# start n threads to process the queue
for i in range(NPIPE):
    Thread(target=process_queue, name='q_msg_%d' % i, args=(i, q_msg)).start()

#read and queue messages, run forever, asynchronous with queue reading process
#prefixes = 'INFO:root:'
prefixes = 'Jul  5 '
while True:
    try:
        message = sys.stdin.readline()
        #logging.info(message)
        if not message or message == '\n':
            continue
        #process the log prefix (I just got the wrong log file???)
        #if message.startswith(prefixes):
        #    message=message[len(prefixes):]
        #processing end
        q_msg.put(message)
    except Exception, err:
        logging.info(err)
        pass
        # myprocess.wait()
